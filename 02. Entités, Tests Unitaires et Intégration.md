# 02 - Entités, Tests Unitaires et Intégration

## Objectif

À la fin de cette journée, vous devriez être capable de créer des entités persistées en base de données, d'écrire des
tests unitaires pour les entités, de créer des formulaires avec des tests fonctionnels associés, et de valider et
persister des données.

## 1. Introduction à Doctrine et création d'entités

### 1.a. Présentation de Doctrine ORM et son rôle dans Symfony

Doctrine ORM (Object-Relational Mapping) est un outil puissant et flexible pour mapper des objets PHP aux tables d'une
base de données relationnelle. Dans Symfony, Doctrine joue un rôle essentiel :

- **Abstraction de Base de Données :** Doctrine fournit une couche d'abstraction pour les interactions avec la base de
  données, permettant aux développeurs de se concentrer sur la logique métier plutôt que sur les détails spécifiques du
  système de gestion de base de données.
- **Manipulation de Données :** Avec Doctrine, les développeurs peuvent effectuer des opérations CRUD (Créer, Lire,
  Mettre à jour, Supprimer) en utilisant des objets PHP, sans écrire de SQL explicite.
- **Mappage Objet-Relationnel :** Doctrine facilite la correspondance entre les entités PHP (classes et objets) et les
  tables de base de données, en gardant le code orienté objet et en réduisant la complexité.

### 1.b. Explication sur la création et la gestion des entités dans Symfony

Les entités dans Symfony/Doctrine sont des classes PHP qui représentent les données que vous souhaitez stocker dans la
base de données. Voici les étapes de base pour créer et gérer des entités :

- **Création d'une Entité :** Pour créer une nouvelle entité, utilisez la commande :

```bash
php bin/console make:entity
```

Cela génère une classe PHP dans le dossier src/Entity avec les annotations Doctrine pour le mappage.

- **Définition des Propriétés :** Les propriétés de l'entité correspondent aux colonnes de la table de la base de
  données. Doctrine utilise des annotations pour mapper ces propriétés.
- **Génération des Getters/Setters :** Après avoir ajouté des propriétés, vous pouvez générer des getters et des setters
  pour ces propriétés à l'aide du même outil.

### 1.c. Relations entre entités et annotations

Doctrine permet de définir des relations entre différentes entités. Les types de relations courants incluent :

- **One-to-One :** Une relation un-à-un entre deux entités.
- **One-to-Many / Many-to-One :** Une relation un-à-plusieurs ou plusieurs-à-un, typique dans les cas de relations
  parent/enfant.
- **Many-to-Many :** Une relation plusieurs-à-plusieurs, souvent gérée via une table de jonction.

Exemple d'annotations pour une relation One-to-Many :

```php
use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity(repositoryClass: ProductRepository::class)]
class Product
{
    // ...

    #[ORM\OneToMany(mappedBy: 'product', targetEntity: Review::class, orphanRemoval: true)]
    private $reviews;

    // ...
}
```

## 2. Configuration de la base de données

### 2.a. Configuration de la connexion à la base de données dans Symfony

La configuration de la connexion à la base de données dans Symfony se fait principalement via le fichier .env situé à la
racine du projet. Voici les étapes et les considérations clés :

- **Fichier .env :** Ce fichier stocke les paramètres d'environnement, y compris les informations de connexion à la base
  de données. Il est important de ne pas stocker ce fichier dans le contrôle de version pour des raisons de sécurité.
- **Paramètre DATABASE_URL :** La connexion à la base de données est configurée avec le paramètre DATABASE_URL. Par
  exemple :

```bash
DATABASE_URL="postgresql://app:!ChangeMe!@127.0.0.1:5432/app?serverVersion=15&charset=utf8" 
```

- **Doctrine Bundle :** Symfony utilise DoctrineBundle pour gérer la configuration de la base de données. Vous pouvez
  personnaliser davantage les paramètres de connexion dans le fichier de configuration de Doctrine, typiquement
  `config/packages/doctrine.yaml`.
- **Commande de vérification :** Après avoir configuré la connexion, vous pouvez vérifier la connexion à la base de
  données avec :

```bash
php bin/console doctrine:database:connect 
```

### 2.b. Bonnes pratiques pour la gestion des environnements de développement, test et production

La gestion des différents environnements (développement, test, production) est cruciale pour la stabilité et la sécurité
de l'application. Voici quelques bonnes pratiques :

- **Fichier .env Local :** Dupliquez les fichiers `.env` et `.env.test` et renommez-les `.env.local`
  et `.env.test.local`. Symfony charge automatiquement le fichier approprié en fonction de l'environnement.
- **Variables d'Environnement :** Utilisez des variables d'environnement pour stocker des informations sensibles telles
  que les identifiants de base de données. Cela empêche de hardcoder des informations confidentielles dans le code
  source.
- **Différenciation des Configurations :** Assurez-vous que la configuration de la base de données, ainsi que d'autres
  paramètres, sont appropriés pour chaque environnement. Par exemple, en production, vous pourriez vouloir activer des
  options de mise en cache plus agressives.
- **Sécurité en Production :** En environnement de production, assurez-vous que les informations de débogage et les
  erreurs ne sont pas exposées aux utilisateurs finaux. Configurez correctement les niveaux de journalisation et
  d'erreur.
- **Tests Automatisés :** Avant de déployer en production, exécutez des tests automatisés dans un environnement de test
  qui imite étroitement la production pour détecter les problèmes potentiels.
- **Migrations Doctrine :** Utilisez les migrations Doctrine pour gérer les changements de schéma de base de données de
  manière contrôlée et cohérente à travers les environnements.

## Mise en pratique : Configuration de la base de données et création des Entités

- Configurer la base de données.
- Utiliser le bundle Maker pour créer les entités (Article, Category).

## 3. Les tests unitaires

### 3.a. Importance des tests unitaires dans le développement logiciel

Les tests unitaires sont essentiels dans le développement logiciel pour plusieurs raisons :

- **Validation de la Logique Individuelle :** Les tests unitaires se concentrent sur des portions isolées du code (comme
  les fonctions ou les méthodes) pour s'assurer qu'elles fonctionnent comme prévu de manière indépendante.
- **Détection Précoce des Erreurs :** Ils aident à identifier les bugs et les problèmes dès le début du cycle de
  développement, ce qui simplifie les corrections et réduit les coûts de débogage.
- **Facilitation des Refactorisations :** Avec des tests unitaires fiables, les développeurs peuvent refactoriser le
  code avec la confiance que les modifications n'introduiront pas de nouveaux bugs.
- **Documentation du Code :** Les tests unitaires servent de documentation, expliquant comment le code est censé être
  utilisé et comment il se comporte dans différentes situations.
- **Assurance Qualité :** Ils fournissent une couche d'assurance qualité, garantissant que le code répond aux exigences
  et fonctionne de manière fiable.
- **Intégration Continue :** Dans les systèmes d'intégration continue, les tests unitaires sont exécutés automatiquement
  lors de chaque push, assurant que les nouvelles modifications n'affectent pas négativement l'application existante.

### 3.b. Présentation de PHPUnit dans le contexte de Symfony

PHPUnit est le framework de test unitaire standard pour les applications PHP, y compris celles développées avec Symfony.
Voici comment il est utilisé dans le contexte de Symfony :

- **Installation et Configuration :** PHPUnit est déjà installé dans un projet Symfony.
- **Écriture des Tests Unitaires :** Les tests unitaires avec PHPUnit sont écrits sous forme de classes PHP dans le
  dossier `tests/`. Chaque méthode de test commence généralement par le mot test ou est annotée avec `@test`.
- **Exécution des Tests :** Pour exécuter les tests unitaires, utilisez la commande :

```bash
php bin/phpunit
```

- **Assertions PHPUnit :** PHPUnit offre une gamme d'assertions pour vérifier que le code se comporte comme prévu. Par
  exemple, `assertEquals` pour vérifier si deux valeurs sont égales.

## Mise en pratique : Écriture de tests unitaires pour les entités

- Écrire les tests unitaires pour valider le fonctionnement des entités.
- Exécuter les tests et interpréter les résultats.

## 4. les FormTypes et leur intégration dans Twig

### 4.a. Présentation des FormTypes dans Symfony

### 4.b. Intégration des FormTypes avec les templates Twig

## Mise en pratique : Création d'un FormType pour la création d'articles et tests fonctionnels associés

- Créer un FormType pour un formulaire de création d'articles.
- Écrire les tests fonctionnels pour valider le formulaire.

## 5. Validation et persistance des données

### 5.a. Mécanismes de validation des données dans Symfony

### 5.b. Persistance des données dans la base de données via Doctrine

## Mise en pratique : Ajout et modification d'article en base de données

- Implémenter les fonctionnalités d'ajout et de modification d'articles.
- Valider les données soumises via le formulaire.

## 6. Tests d'intégration

### 6.a. Distinction entre tests unitaires et tests d'intégration

### 6.b. Importance des tests d'intégration dans le cadre de projets complexes

## Mise en pratique : Tests d'intégration pour valider la création et la modification d'articles

- Écrire les tests d'intégration pour les fonctionnalités de création et modification d'articles.
- Exécuter les tests et analyser les résultats.
